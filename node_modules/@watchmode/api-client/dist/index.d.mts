type AuthToken = string | undefined;
interface Auth {
    /**
     * Which part of the request do we use to send the auth?
     *
     * @default 'header'
     */
    in?: 'header' | 'query' | 'cookie';
    /**
     * Header or query parameter name.
     *
     * @default 'Authorization'
     */
    name?: string;
    scheme?: 'basic' | 'bearer';
    type: 'apiKey' | 'http';
}

interface SerializerOptions<T> {
    /**
     * @default true
     */
    explode: boolean;
    style: T;
}
type ArrayStyle = 'form' | 'spaceDelimited' | 'pipeDelimited';
type ObjectStyle = 'form' | 'deepObject';

type QuerySerializer = (query: Record<string, unknown>) => string;
type BodySerializer = (body: any) => any;
type QuerySerializerOptionsObject = {
    allowReserved?: boolean;
    array?: Partial<SerializerOptions<ArrayStyle>>;
    object?: Partial<SerializerOptions<ObjectStyle>>;
};
type QuerySerializerOptions = QuerySerializerOptionsObject & {
    /**
     * Per-parameter serialization overrides. When provided, these settings
     * override the global array/object settings for specific parameter names.
     */
    parameters?: Record<string, QuerySerializerOptionsObject>;
};

type HttpMethod = 'connect' | 'delete' | 'get' | 'head' | 'options' | 'patch' | 'post' | 'put' | 'trace';
type Client$1<RequestFn = never, Config = unknown, MethodFn = never, BuildUrlFn = never, SseFn = never> = {
    /**
     * Returns the final request URL.
     */
    buildUrl: BuildUrlFn;
    getConfig: () => Config;
    request: RequestFn;
    setConfig: (config: Config) => Config;
} & {
    [K in HttpMethod]: MethodFn;
} & ([SseFn] extends [never] ? {
    sse?: never;
} : {
    sse: {
        [K in HttpMethod]: SseFn;
    };
});
interface Config$1 {
    /**
     * Auth token or a function returning auth token. The resolved value will be
     * added to the request payload as defined by its `security` array.
     */
    auth?: ((auth: Auth) => Promise<AuthToken> | AuthToken) | AuthToken;
    /**
     * A function for serializing request body parameter. By default,
     * {@link JSON.stringify()} will be used.
     */
    bodySerializer?: BodySerializer | null;
    /**
     * An object containing any HTTP headers that you want to pre-populate your
     * `Headers` object with.
     *
     * {@link https://developer.mozilla.org/docs/Web/API/Headers/Headers#init See more}
     */
    headers?: RequestInit['headers'] | Record<string, string | number | boolean | (string | number | boolean)[] | null | undefined | unknown>;
    /**
     * The request method.
     *
     * {@link https://developer.mozilla.org/docs/Web/API/fetch#method See more}
     */
    method?: Uppercase<HttpMethod>;
    /**
     * A function for serializing request query parameters. By default, arrays
     * will be exploded in form style, objects will be exploded in deepObject
     * style, and reserved characters are percent-encoded.
     *
     * This method will have no effect if the native `paramsSerializer()` Axios
     * API function is used.
     *
     * {@link https://swagger.io/docs/specification/serialization/#query View examples}
     */
    querySerializer?: QuerySerializer | QuerySerializerOptions;
    /**
     * A function validating request data. This is useful if you want to ensure
     * the request conforms to the desired shape, so it can be safely sent to
     * the server.
     */
    requestValidator?: (data: unknown) => Promise<unknown>;
    /**
     * A function transforming response data before it's returned. This is useful
     * for post-processing data, e.g. converting ISO strings into Date objects.
     */
    responseTransformer?: (data: unknown) => Promise<unknown>;
    /**
     * A function validating response data. This is useful if you want to ensure
     * the response conforms to the desired shape, so it can be safely passed to
     * the transformers and returned to the user.
     */
    responseValidator?: (data: unknown) => Promise<unknown>;
}

type ServerSentEventsOptions<TData = unknown> = Omit<RequestInit, 'method'> & Pick<Config$1, 'method' | 'responseTransformer' | 'responseValidator'> & {
    /**
     * Fetch API implementation. You can use this option to provide a custom
     * fetch instance.
     *
     * @default globalThis.fetch
     */
    fetch?: typeof fetch;
    /**
     * Implementing clients can call request interceptors inside this hook.
     */
    onRequest?: (url: string, init: RequestInit) => Promise<Request>;
    /**
     * Callback invoked when a network or parsing error occurs during streaming.
     *
     * This option applies only if the endpoint returns a stream of events.
     *
     * @param error The error that occurred.
     */
    onSseError?: (error: unknown) => void;
    /**
     * Callback invoked when an event is streamed from the server.
     *
     * This option applies only if the endpoint returns a stream of events.
     *
     * @param event Event streamed from the server.
     * @returns Nothing (void).
     */
    onSseEvent?: (event: StreamEvent<TData>) => void;
    serializedBody?: RequestInit['body'];
    /**
     * Default retry delay in milliseconds.
     *
     * This option applies only if the endpoint returns a stream of events.
     *
     * @default 3000
     */
    sseDefaultRetryDelay?: number;
    /**
     * Maximum number of retry attempts before giving up.
     */
    sseMaxRetryAttempts?: number;
    /**
     * Maximum retry delay in milliseconds.
     *
     * Applies only when exponential backoff is used.
     *
     * This option applies only if the endpoint returns a stream of events.
     *
     * @default 30000
     */
    sseMaxRetryDelay?: number;
    /**
     * Optional sleep function for retry backoff.
     *
     * Defaults to using `setTimeout`.
     */
    sseSleepFn?: (ms: number) => Promise<void>;
    url: string;
};
interface StreamEvent<TData = unknown> {
    data: TData;
    event?: string;
    id?: string;
    retry?: number;
}
type ServerSentEventsResult<TData = unknown, TReturn = void, TNext = unknown> = {
    stream: AsyncGenerator<TData extends Record<string, unknown> ? TData[keyof TData] : TData, TReturn, TNext>;
};

type ErrInterceptor<Err, Res, Req, Options> = (error: Err, response: Res, request: Req, options: Options) => Err | Promise<Err>;
type ReqInterceptor<Req, Options> = (request: Req, options: Options) => Req | Promise<Req>;
type ResInterceptor<Res, Req, Options> = (response: Res, request: Req, options: Options) => Res | Promise<Res>;
declare class Interceptors<Interceptor> {
    fns: Array<Interceptor | null>;
    clear(): void;
    eject(id: number | Interceptor): void;
    exists(id: number | Interceptor): boolean;
    getInterceptorIndex(id: number | Interceptor): number;
    update(id: number | Interceptor, fn: Interceptor): number | Interceptor | false;
    use(fn: Interceptor): number;
}
interface Middleware<Req, Res, Err, Options> {
    error: Interceptors<ErrInterceptor<Err, Res, Req, Options>>;
    request: Interceptors<ReqInterceptor<Req, Options>>;
    response: Interceptors<ResInterceptor<Res, Req, Options>>;
}

type ResponseStyle = 'data' | 'fields';
interface Config<T extends ClientOptions$1 = ClientOptions$1> extends Omit<RequestInit, 'body' | 'headers' | 'method'>, Config$1 {
    /**
     * Base URL for all requests made by this client.
     */
    baseUrl?: T['baseUrl'];
    /**
     * Fetch API implementation. You can use this option to provide a custom
     * fetch instance.
     *
     * @default globalThis.fetch
     */
    fetch?: typeof fetch;
    /**
     * Please don't use the Fetch client for Next.js applications. The `next`
     * options won't have any effect.
     *
     * Install {@link https://www.npmjs.com/package/@hey-api/client-next `@hey-api/client-next`} instead.
     */
    next?: never;
    /**
     * Return the response data parsed in a specified format. By default, `auto`
     * will infer the appropriate method from the `Content-Type` response header.
     * You can override this behavior with any of the {@link Body} methods.
     * Select `stream` if you don't want to parse response data at all.
     *
     * @default 'auto'
     */
    parseAs?: 'arrayBuffer' | 'auto' | 'blob' | 'formData' | 'json' | 'stream' | 'text';
    /**
     * Should we return only data or multiple fields (data, error, response, etc.)?
     *
     * @default 'fields'
     */
    responseStyle?: ResponseStyle;
    /**
     * Throw an error instead of returning it in the response?
     *
     * @default false
     */
    throwOnError?: T['throwOnError'];
}
interface RequestOptions<TData = unknown, TResponseStyle extends ResponseStyle = 'fields', ThrowOnError extends boolean = boolean, Url extends string = string> extends Config<{
    responseStyle: TResponseStyle;
    throwOnError: ThrowOnError;
}>, Pick<ServerSentEventsOptions<TData>, 'onSseError' | 'onSseEvent' | 'sseDefaultRetryDelay' | 'sseMaxRetryAttempts' | 'sseMaxRetryDelay'> {
    /**
     * Any body that you want to add to your request.
     *
     * {@link https://developer.mozilla.org/docs/Web/API/fetch#body}
     */
    body?: unknown;
    path?: Record<string, unknown>;
    query?: Record<string, unknown>;
    /**
     * Security mechanism(s) to use for the request.
     */
    security?: ReadonlyArray<Auth>;
    url: Url;
}
interface ResolvedRequestOptions<TResponseStyle extends ResponseStyle = 'fields', ThrowOnError extends boolean = boolean, Url extends string = string> extends RequestOptions<unknown, TResponseStyle, ThrowOnError, Url> {
    serializedBody?: string;
}
type RequestResult<TData = unknown, TError = unknown, ThrowOnError extends boolean = boolean, TResponseStyle extends ResponseStyle = 'fields'> = ThrowOnError extends true ? Promise<TResponseStyle extends 'data' ? TData extends Record<string, unknown> ? TData[keyof TData] : TData : {
    data: TData extends Record<string, unknown> ? TData[keyof TData] : TData;
    request: Request;
    response: Response;
}> : Promise<TResponseStyle extends 'data' ? (TData extends Record<string, unknown> ? TData[keyof TData] : TData) | undefined : ({
    data: TData extends Record<string, unknown> ? TData[keyof TData] : TData;
    error: undefined;
} | {
    data: undefined;
    error: TError extends Record<string, unknown> ? TError[keyof TError] : TError;
}) & {
    request: Request;
    response: Response;
}>;
interface ClientOptions$1 {
    baseUrl?: string;
    responseStyle?: ResponseStyle;
    throwOnError?: boolean;
}
type MethodFn = <TData = unknown, TError = unknown, ThrowOnError extends boolean = false, TResponseStyle extends ResponseStyle = 'fields'>(options: Omit<RequestOptions<TData, TResponseStyle, ThrowOnError>, 'method'>) => RequestResult<TData, TError, ThrowOnError, TResponseStyle>;
type SseFn = <TData = unknown, TError = unknown, ThrowOnError extends boolean = false, TResponseStyle extends ResponseStyle = 'fields'>(options: Omit<RequestOptions<TData, TResponseStyle, ThrowOnError>, 'method'>) => Promise<ServerSentEventsResult<TData, TError>>;
type RequestFn = <TData = unknown, TError = unknown, ThrowOnError extends boolean = false, TResponseStyle extends ResponseStyle = 'fields'>(options: Omit<RequestOptions<TData, TResponseStyle, ThrowOnError>, 'method'> & Pick<Required<RequestOptions<TData, TResponseStyle, ThrowOnError>>, 'method'>) => RequestResult<TData, TError, ThrowOnError, TResponseStyle>;
type BuildUrlFn = <TData extends {
    body?: unknown;
    path?: Record<string, unknown>;
    query?: Record<string, unknown>;
    url: string;
}>(options: TData & Options<TData>) => string;
type Client = Client$1<RequestFn, Config, MethodFn, BuildUrlFn, SseFn> & {
    interceptors: Middleware<Request, Response, unknown, ResolvedRequestOptions>;
};
interface TDataShape {
    body?: unknown;
    headers?: unknown;
    path?: unknown;
    query?: unknown;
    url: string;
}
type OmitKeys<T, K> = Pick<T, Exclude<keyof T, K>>;
type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean, TResponse = unknown, TResponseStyle extends ResponseStyle = 'fields'> = OmitKeys<RequestOptions<TResponse, TResponseStyle, ThrowOnError>, 'body' | 'path' | 'query' | 'url'> & ([TData] extends [never] ? unknown : Omit<TData, 'url'>);

type ClientOptions = {
    baseUrl: 'https://api.watchmode.com/v1' | (string & {});
};
type _Error = {
    success: boolean;
    statusCode: number;
    statusMessage: string;
};
type StatusResponse = {
    /**
     * Monthly API quota limit
     */
    quota?: number;
    /**
     * API calls used this month
     */
    quotaUsed?: number;
};
type Source = {
    /**
     * Unique source ID
     */
    id?: number;
    /**
     * Source name
     */
    name?: string;
    /**
     * Source type
     */
    type?: 'sub' | 'rent' | 'buy' | 'free' | 'tve';
    /**
     * URL to 100px logo
     */
    logo_100px?: string;
    /**
     * iOS App Store URL
     */
    ios_appstore_url?: string;
    /**
     * Google Play Store URL
     */
    android_playstore_url?: string;
    android_tv_url?: string;
    fire_tv_url?: string;
    roku_url?: string;
    tvos_url?: string;
    /**
     * Supported 2-letter country codes
     */
    regions?: Array<string>;
};
type Region = {
    /**
     * 2-letter country code
     */
    country?: string;
    /**
     * Country name
     */
    name?: string;
    /**
     * URL to flag image
     */
    flag?: string;
    /**
     * Data quality tier (1 = highest)
     */
    data_tier?: 1 | 2;
    /**
     * Whether region is enabled for your plan
     */
    plan_enabled?: boolean;
};
type Network = {
    /**
     * Watchmode network ID
     */
    id?: number;
    /**
     * Network name
     */
    name?: string;
    /**
     * 2-letter country code
     */
    origin_country?: string;
    /**
     * TMDB network ID (0 if not available)
     */
    tmdb_id?: number;
};
type Genre = {
    /**
     * Watchmode genre ID
     */
    id?: number;
    /**
     * Genre name
     */
    name?: string;
    /**
     * TMDB genre ID (0 if not available)
     */
    tmdb_id?: number;
};
type SearchResponse = {
    title_results?: Array<TitleSearchResult>;
    people_results?: Array<PersonSearchResult>;
};
type TitleSearchResult = {
    /**
     * Watchmode title ID
     */
    id?: number;
    /**
     * Title name
     */
    name?: string;
    type?: 'movie' | 'tv_series' | 'tv_special' | 'tv_miniseries' | 'short_film' | 'tv_movie';
    /**
     * Release year
     */
    year?: number;
    /**
     * IMDB ID
     */
    imdb_id?: string;
    /**
     * TMDB ID
     */
    tmdb_id?: number;
    /**
     * TMDB type
     */
    tmdb_type?: 'movie' | 'tv';
};
type PersonSearchResult = {
    /**
     * Watchmode person ID
     */
    id?: number;
    /**
     * Person name
     */
    name?: string;
    /**
     * Primary profession
     */
    main_profession?: string;
    /**
     * IMDB person ID
     */
    imdb_id?: string;
    /**
     * TMDB person ID
     */
    tmdb_id?: number;
};
type AutocompleteResponse = {
    results?: Array<AutocompleteResult>;
};
type AutocompleteResult = {
    /**
     * Title or person name
     */
    name?: string;
    /**
     * Relevance score
     */
    relevance?: number;
    /**
     * Title type (for titles)
     */
    type?: string;
    /**
     * Watchmode ID
     */
    id?: number;
    /**
     * Release year (for titles)
     */
    year?: number;
    /**
     * Whether result is a title or person
     */
    result_type?: 'title' | 'person';
    imdb_id?: string;
    tmdb_id?: number;
    tmdb_type?: 'movie' | 'tv';
    /**
     * Poster (titles) or headshot (people)
     */
    image_url?: string;
};
type ListTitlesResponse = {
    titles?: Array<TitleListItem>;
    /**
     * Current page number
     */
    page?: number;
    /**
     * Total matching titles
     */
    total_results?: number;
    /**
     * Total pages available
     */
    total_pages?: number;
};
type TitleListItem = {
    id?: number;
    title?: string;
    year?: number;
    imdb_id?: string;
    tmdb_id?: number;
    tmdb_type?: 'movie' | 'tv';
    type?: 'movie' | 'tv_series' | 'tv_special' | 'tv_miniseries' | 'short_film' | 'tv_movie';
};
type TitleDetails = {
    id?: number;
    title?: string;
    original_title?: string;
    plot_overview?: string;
    type?: 'movie' | 'tv_series' | 'tv_special' | 'tv_miniseries' | 'short_film' | 'tv_movie';
    runtime_minutes?: number;
    year?: number;
    /**
     * For TV series, the year the show ended
     */
    end_year?: number;
    release_date?: string;
    imdb_id?: string;
    tmdb_id?: number;
    tmdb_type?: 'movie' | 'tv';
    /**
     * Array of genre IDs
     */
    genres?: Array<number>;
    /**
     * Array of genre names
     */
    genre_names?: Array<string>;
    /**
     * User rating (0-10)
     */
    user_rating?: number;
    /**
     * Critic score (0-100)
     */
    critic_score?: number;
    /**
     * US content rating
     */
    us_rating?: string;
    poster?: string;
    backdrop?: string;
    /**
     * ISO 639-1 language code
     */
    original_language?: string;
    /**
     * Network IDs (for TV)
     */
    networks?: Array<number>;
    /**
     * Network names (for TV)
     */
    network_names?: Array<string>;
    /**
     * Popularity percentile (0-100)
     */
    relevance_percentile?: number;
    /**
     * English title (when language param is not EN)
     */
    english_title?: string;
    /**
     * Streaming sources (when append_to_response=sources)
     */
    sources?: Array<TitleSource>;
    /**
     * Seasons (when append_to_response=seasons)
     */
    seasons?: Array<Season>;
    /**
     * Episodes (when append_to_response=episodes)
     */
    episodes?: Array<Episode>;
    /**
     * Cast/crew (when append_to_response=cast-crew)
     */
    cast?: Array<CastCrew>;
};
/**
 * Streaming source availability for a title.
 *
 * **Plan-dependent fields:**
 * - `ios_url` and `android_url`: For free plans, returns the string "Deeplinks available for paid plans only." instead of a URL
 * - `tvos_url`, `android_tv_url`, `roku_url`: Only included if TV links are enabled for your account
 *
 */
type TitleSource = {
    source_id?: number;
    name?: string;
    type?: 'sub' | 'rent' | 'buy' | 'free' | 'tve';
    region?: string;
    /**
     * iOS deep link URL. For free plans, returns "Deeplinks available for paid plans only."
     *
     */
    ios_url?: string;
    /**
     * Android deep link URL. For free plans, returns "Deeplinks available for paid plans only."
     *
     */
    android_url?: string;
    /**
     * Web URL to watch the title
     */
    web_url?: string;
    /**
     * tvOS deep link. **Only included if TV links are enabled for your account.**
     *
     */
    tvos_url?: string;
    /**
     * Android TV deep link. **Only included if TV links are enabled for your account.**
     *
     */
    android_tv_url?: string;
    /**
     * Roku deep link. **Only included if TV links are enabled for your account.**
     *
     */
    roku_url?: string;
    /**
     * Video quality (HD, 4K, etc.)
     */
    format?: string;
    /**
     * Price for rent/buy sources
     */
    price?: number;
    /**
     * Number of seasons available (for TV)
     */
    seasons?: number;
    /**
     * Number of episodes available (for TV)
     */
    episodes?: number;
};
type Season = {
    id?: number;
    poster_url?: string;
    name?: string;
    overview?: string;
    /**
     * Season number
     */
    number?: number;
    air_date?: string;
    episode_count?: number;
};
type Episode = {
    id?: number;
    name?: string;
    episode_number?: number;
    season_number?: number;
    season_id?: number;
    tmdb_id?: number;
    imdb_id?: string;
    thumbnail_url?: string;
    release_date?: string;
    runtime_minutes?: number;
    overview?: string;
    sources?: Array<EpisodeSource>;
};
/**
 * Streaming source for an episode.
 *
 * **Plan-dependent fields:**
 * - `ios_url` and `android_url`: For free plans, returns "Deeplinks available for paid plans only."
 * - `web_url`: For free plans, returns "Episode links available for paid plans only."
 * - `tvos_url`, `android_tv_url`, `roku_url`: Only included if TV links are enabled for your account
 *
 */
type EpisodeSource = {
    source_id?: number;
    name?: string;
    type?: 'sub' | 'rent' | 'buy' | 'free' | 'tve';
    region?: string;
    /**
     * iOS deep link. For free plans, returns message string.
     */
    ios_url?: string;
    /**
     * Android deep link. For free plans, returns message string.
     */
    android_url?: string;
    /**
     * Web URL. For free plans, returns message string.
     */
    web_url?: string;
    /**
     * tvOS deep link (only if TV links enabled)
     */
    tvos_url?: string;
    /**
     * Android TV deep link (only if TV links enabled)
     */
    android_tv_url?: string;
    /**
     * Roku deep link (only if TV links enabled)
     */
    roku_url?: string;
    /**
     * Video quality
     */
    format?: string;
    /**
     * Price for rent/buy
     */
    price?: number;
};
type CastCrew = {
    /**
     * Watchmode person ID
     */
    person_id?: number;
    type?: 'Cast' | 'Crew';
    full_name?: string;
    headshot_url?: string;
    /**
     * Character name (cast) or job title (crew)
     */
    role?: string;
    /**
     * Number of episodes (for TV)
     */
    episode_count?: number;
    /**
     * Billing order
     */
    order?: number;
};
type Person = {
    id?: number;
    full_name?: string;
    first_name?: string;
    last_name?: string;
    tmdb_id?: number;
    imdb_id?: string;
    main_profession?: string;
    secondary_profession?: string;
    tertiary_profession?: string;
    date_of_birth?: string;
    date_of_death?: string;
    place_of_birth?: string;
    gender?: 'm' | 'f';
    headshot_url?: string;
    /**
     * Array of title IDs person is known for
     */
    known_for?: Array<number>;
    /**
     * Popularity percentile (0-100)
     */
    relevance_percentile?: number;
};
type ReleasesResponse = {
    releases?: Array<Release>;
};
type Release = {
    id?: number;
    title?: string;
    type?: 'movie' | 'tv_series' | 'tv_special' | 'tv_miniseries' | 'short_film' | 'tv_movie';
    tmdb_id?: number;
    tmdb_type?: 'movie' | 'tv';
    imdb_id?: string;
    /**
     * Season number (for TV)
     */
    season_number?: number;
    poster_url?: string;
    source_release_date?: string;
    source_id?: number;
    source_name?: string;
    /**
     * Whether this is an original release on this service
     */
    is_original?: 0 | 1;
};
type TitleReleaseDate = {
    id?: number;
    title?: string;
    title_type?: 'movie' | 'tv_series' | 'tv_special' | 'tv_miniseries' | 'short_film' | 'tv_movie';
    region?: string;
    type?: 'streaming_movie_release' | 'streaming_tv_season_release' | 'theatrical_release';
    release_date?: string;
    /**
     * Streaming provider ID (null for theatrical)
     */
    provider_id?: number;
    /**
     * Season number (for TV releases)
     */
    season?: number;
};
type ChangesResponse = {
    /**
     * Array of title IDs
     */
    titles?: Array<number>;
    page?: number;
    total_results?: number;
    total_pages?: number;
};
type PeopleChangesResponse = {
    /**
     * Array of person IDs
     */
    people?: Array<number>;
    page?: number;
    total_results?: number;
    total_pages?: number;
};
/**
 * Title identifier. Accepts:
 * - Watchmode ID (e.g., `345534`) - 1 credit
 * - IMDB ID (e.g., `tt0903747`) - 2 credits
 * - TMDB format (e.g., `movie-278` or `tv-1396`) - 2 credits
 *
 */
type TitleId = string;
/**
 * Page number for pagination
 */
type Page = number;
/**
 * Results per page (1-250)
 */
type ChangesLimit = number;
/**
 * Get changes after this date (PST timezone).
 * Format: `YYYYMMDD` or `YYYYMMDDHHMMSS`
 * Default: 1 day ago
 *
 */
type StartDate = number;
/**
 * Get changes before this date (PST timezone).
 * Format: `YYYYMMDD` or `YYYYMMDDHHMMSS`
 * Default: current date
 *
 */
type EndDate = number;
/**
 * Filter by title type. Comma-separated.
 */
type TitleTypes = string;
type GetStatusData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/status';
};
type GetStatusErrors = {
    /**
     * Invalid or missing API key
     */
    401: _Error;
};
type GetStatusError = GetStatusErrors[keyof GetStatusErrors];
type GetStatusResponses = {
    /**
     * Quota status retrieved successfully
     */
    200: StatusResponse;
};
type GetStatusResponse = GetStatusResponses[keyof GetStatusResponses];
type GetSourcesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filter sources by region. Pass one or multiple 2-letter country codes comma-separated (e.g., `US,GB,CA`).
         */
        regions?: string;
        /**
         * Filter sources by type. Pass one or multiple types comma-separated.
         * - `sub` - Subscription services (Netflix, Hulu, etc.)
         * - `rent` - Rental services
         * - `buy` - Purchase services
         * - `free` - Free ad-supported services
         * - `tve` - TV Everywhere (cable login required)
         *
         */
        types?: string;
    };
    url: '/sources';
};
type GetSourcesErrors = {
    /**
     * Invalid or missing API key
     */
    401: _Error;
};
type GetSourcesError = GetSourcesErrors[keyof GetSourcesErrors];
type GetSourcesResponses = {
    /**
     * List of streaming sources
     */
    200: Array<Source>;
};
type GetSourcesResponse = GetSourcesResponses[keyof GetSourcesResponses];
type GetRegionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/regions';
};
type GetRegionsErrors = {
    /**
     * Invalid or missing API key
     */
    401: _Error;
};
type GetRegionsError = GetRegionsErrors[keyof GetRegionsErrors];
type GetRegionsResponses = {
    /**
     * List of supported regions
     */
    200: Array<Region>;
};
type GetRegionsResponse = GetRegionsResponses[keyof GetRegionsResponses];
type GetNetworksData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/networks';
};
type GetNetworksErrors = {
    /**
     * Invalid or missing API key
     */
    401: _Error;
};
type GetNetworksError = GetNetworksErrors[keyof GetNetworksErrors];
type GetNetworksResponses = {
    /**
     * List of TV networks
     */
    200: Array<Network>;
};
type GetNetworksResponse = GetNetworksResponses[keyof GetNetworksResponses];
type GetGenresData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/genres';
};
type GetGenresErrors = {
    /**
     * Invalid or missing API key
     */
    401: _Error;
};
type GetGenresError = GetGenresErrors[keyof GetGenresErrors];
type GetGenresResponses = {
    /**
     * List of genres
     */
    200: Array<Genre>;
};
type GetGenresResponse = GetGenresResponses[keyof GetGenresResponses];
type SearchData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The field to search in:
         * - `name` - Search by title or person name
         * - `imdb_id` - Search by IMDB ID (e.g., tt0944947)
         * - `tmdb_movie_id` - Search by TMDB movie ID
         * - `tmdb_tv_id` - Search by TMDB TV show ID
         * - `tmdb_person_id` - Search by TMDB person ID
         *
         */
        search_field: 'name' | 'imdb_id' | 'tmdb_movie_id' | 'tmdb_tv_id' | 'tmdb_person_id';
        /**
         * The value to search for (e.g., "Breaking Bad", "tt0944947")
         */
        search_value: string;
        /**
         * Filter results by type. Pass comma-separated values (e.g., `tv,movie,person`)
         */
        types?: string;
    };
    url: '/search';
};
type SearchErrors = {
    /**
     * Invalid request parameters
     */
    400: _Error;
    /**
     * Invalid or missing API key
     */
    401: _Error;
};
type SearchError = SearchErrors[keyof SearchErrors];
type SearchResponses = {
    /**
     * Search results
     */
    200: SearchResponse;
};
type SearchResponse2 = SearchResponses[keyof SearchResponses];
type AutocompleteSearchData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The search phrase (can be partial, e.g., "The Sha" will find "The Shawshank Redemption")
         */
        search_value: string;
        /**
         * Filter result types:
         * - `1` - Titles and people (default)
         * - `2` - Titles only
         * - `3` - Movies only
         * - `4` - TV shows only
         * - `5` - People only
         *
         */
        search_type?: 1 | 2 | 3 | 4 | 5;
    };
    url: '/autocomplete-search';
};
type AutocompleteSearchErrors = {
    /**
     * Invalid request parameters
     */
    400: _Error;
    /**
     * Invalid or missing API key
     */
    401: _Error;
};
type AutocompleteSearchError = AutocompleteSearchErrors[keyof AutocompleteSearchErrors];
type AutocompleteSearchResponses = {
    /**
     * Autocomplete results
     */
    200: AutocompleteResponse;
};
type AutocompleteSearchResponse = AutocompleteSearchResponses[keyof AutocompleteSearchResponses];
type ListTitlesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filter by title type. Comma-separated values.
         */
        types?: 'movie' | 'tv_series' | 'tv_special' | 'tv_miniseries' | 'short_film';
        /**
         * Filter by region (2-letter country code). Comma-separated for multiple.
         */
        regions?: string;
        /**
         * Filter by source type. Comma-separated values.
         * - `sub` - Subscription
         * - `rent` - Rental
         * - `buy` - Purchase
         * - `free` - Free
         * - `tve` - TV Everywhere
         *
         */
        source_types?: string;
        /**
         * Filter by specific source IDs (from `/sources` endpoint). Comma-separated.
         */
        source_ids?: string;
        /**
         * Filter by genre IDs (from `/genres` endpoint). Comma-separated.
         */
        genres?: string;
        /**
         * Filter by network IDs (from `/networks` endpoint). Comma-separated.
         */
        network_ids?: string;
        /**
         * Filter by primary language (2-letter ISO 639 code). Comma-separated.
         */
        languages?: string;
        /**
         * Filter by release date start (format YYYYMMDD)
         */
        release_date_start?: number;
        /**
         * Filter by release date end (format YYYYMMDD)
         */
        release_date_end?: number;
        /**
         * Minimum user rating (0-10)
         */
        user_rating_low?: number;
        /**
         * Maximum user rating (0-10)
         */
        user_rating_high?: number;
        /**
         * Minimum critic score (0-100)
         */
        critic_score_low?: number;
        /**
         * Maximum critic score (0-100)
         */
        critic_score_high?: number;
        /**
         * Filter by person ID (actor, director, etc.)
         */
        person_id?: number;
        /**
         * Sort order for results
         */
        sort_by?: 'relevance_desc' | 'relevance_asc' | 'popularity_desc' | 'popularity_asc' | 'release_date_desc' | 'release_date_asc' | 'title_desc' | 'title_asc';
        /**
         * Page number for pagination
         */
        page?: number;
        /**
         * Results per page (1-250)
         */
        limit?: number;
    };
    url: '/list-titles';
};
type ListTitlesErrors = {
    /**
     * Invalid request parameters
     */
    400: _Error;
    /**
     * Invalid or missing API key
     */
    401: _Error;
};
type ListTitlesError = ListTitlesErrors[keyof ListTitlesErrors];
type ListTitlesResponses = {
    /**
     * Paginated list of titles
     */
    200: ListTitlesResponse;
};
type ListTitlesResponse2 = ListTitlesResponses[keyof ListTitlesResponses];
type GetTitleDetailsData = {
    body?: never;
    path: {
        /**
         * Title identifier. Accepts:
         * - Watchmode ID (e.g., `345534`) - 1 credit
         * - IMDB ID (e.g., `tt0903747`) - 2 credits
         * - TMDB format (e.g., `movie-278` or `tv-1396`) - 2 credits
         *
         */
        title_id: string;
    };
    query?: {
        /**
         * Include additional data. Comma-separated values. Each adds 1 credit.
         * - `sources` - Streaming availability
         * - `seasons` - Season list (TV only)
         * - `episodes` - Episode list with sources (TV only)
         * - `cast-crew` - Cast and crew
         *
         */
        append_to_response?: string;
        /**
         * ISO 639-1 language code for localized title/overview (default `en`)
         */
        language?: string;
        /**
         * Filter sources by region when using `append_to_response=sources`. Comma-separated.
         */
        regions?: string;
    };
    url: '/title/{title_id}/details';
};
type GetTitleDetailsErrors = {
    /**
     * Invalid or missing API key
     */
    401: _Error;
    /**
     * Resource not found
     */
    404: _Error;
};
type GetTitleDetailsError = GetTitleDetailsErrors[keyof GetTitleDetailsErrors];
type GetTitleDetailsResponses = {
    /**
     * Title details
     */
    200: TitleDetails;
};
type GetTitleDetailsResponse = GetTitleDetailsResponses[keyof GetTitleDetailsResponses];
type GetTitleSourcesData = {
    body?: never;
    path: {
        /**
         * Title identifier. Accepts:
         * - Watchmode ID (e.g., `345534`) - 1 credit
         * - IMDB ID (e.g., `tt0903747`) - 2 credits
         * - TMDB format (e.g., `movie-278` or `tv-1396`) - 2 credits
         *
         */
        title_id: string;
    };
    query?: {
        /**
         * Filter by region (2-letter country code). Comma-separated for multiple. Default returns all regions.
         */
        regions?: string;
    };
    url: '/title/{title_id}/sources';
};
type GetTitleSourcesErrors = {
    /**
     * Invalid or missing API key
     */
    401: _Error;
    /**
     * Resource not found
     */
    404: _Error;
};
type GetTitleSourcesError = GetTitleSourcesErrors[keyof GetTitleSourcesErrors];
type GetTitleSourcesResponses = {
    /**
     * List of streaming sources
     */
    200: Array<TitleSource>;
};
type GetTitleSourcesResponse = GetTitleSourcesResponses[keyof GetTitleSourcesResponses];
type GetTitleSeasonsData = {
    body?: never;
    path: {
        /**
         * Title identifier. Accepts:
         * - Watchmode ID (e.g., `345534`) - 1 credit
         * - IMDB ID (e.g., `tt0903747`) - 2 credits
         * - TMDB format (e.g., `movie-278` or `tv-1396`) - 2 credits
         *
         */
        title_id: string;
    };
    query?: never;
    url: '/title/{title_id}/seasons';
};
type GetTitleSeasonsErrors = {
    /**
     * Invalid or missing API key
     */
    401: _Error;
    /**
     * Resource not found
     */
    404: _Error;
};
type GetTitleSeasonsError = GetTitleSeasonsErrors[keyof GetTitleSeasonsErrors];
type GetTitleSeasonsResponses = {
    /**
     * List of seasons
     */
    200: Array<Season>;
};
type GetTitleSeasonsResponse = GetTitleSeasonsResponses[keyof GetTitleSeasonsResponses];
type GetTitleEpisodesData = {
    body?: never;
    path: {
        /**
         * Title identifier. Accepts:
         * - Watchmode ID (e.g., `345534`) - 1 credit
         * - IMDB ID (e.g., `tt0903747`) - 2 credits
         * - TMDB format (e.g., `movie-278` or `tv-1396`) - 2 credits
         *
         */
        title_id: string;
    };
    query?: never;
    url: '/title/{title_id}/episodes';
};
type GetTitleEpisodesErrors = {
    /**
     * Invalid or missing API key
     */
    401: _Error;
    /**
     * Resource not found
     */
    404: _Error;
};
type GetTitleEpisodesError = GetTitleEpisodesErrors[keyof GetTitleEpisodesErrors];
type GetTitleEpisodesResponses = {
    /**
     * List of episodes with sources
     */
    200: Array<Episode>;
};
type GetTitleEpisodesResponse = GetTitleEpisodesResponses[keyof GetTitleEpisodesResponses];
type GetTitleCastCrewData = {
    body?: never;
    path: {
        /**
         * Title identifier. Accepts:
         * - Watchmode ID (e.g., `345534`) - 1 credit
         * - IMDB ID (e.g., `tt0903747`) - 2 credits
         * - TMDB format (e.g., `movie-278` or `tv-1396`) - 2 credits
         *
         */
        title_id: string;
    };
    query?: {
        /**
         * ISO 639-1 language code for localized names (default `en`)
         */
        language?: string;
    };
    url: '/title/{title_id}/cast-crew';
};
type GetTitleCastCrewErrors = {
    /**
     * Invalid or missing API key
     */
    401: _Error;
    /**
     * Resource not found
     */
    404: _Error;
};
type GetTitleCastCrewError = GetTitleCastCrewErrors[keyof GetTitleCastCrewErrors];
type GetTitleCastCrewResponses = {
    /**
     * Cast and crew list
     */
    200: Array<CastCrew>;
};
type GetTitleCastCrewResponse = GetTitleCastCrewResponses[keyof GetTitleCastCrewResponses];
type ReportIncorrectDataData = {
    body?: never;
    path: {
        /**
         * Title identifier. Accepts:
         * - Watchmode ID (e.g., `345534`) - 1 credit
         * - IMDB ID (e.g., `tt0903747`) - 2 credits
         * - TMDB format (e.g., `movie-278` or `tv-1396`) - 2 credits
         *
         */
        title_id: string;
    };
    query?: {
        /**
         * Flag indicating description/overview is incorrect (1 = yes)
         */
        somethingWrongDescription?: 0 | 1;
        /**
         * Flag indicating streaming service info is incorrect (1 = yes)
         */
        serviceIncorrect?: 0 | 1;
        /**
         * Flag indicating a streaming source is missing (1 = yes)
         */
        sourceMissing?: 0 | 1;
        /**
         * Flag indicating other issue (1 = yes)
         */
        somethingElseWrong?: 0 | 1;
        /**
         * Free-text description of the issue
         */
        somethingWrongDetails?: string;
    };
    url: '/title/{title_id}/incorrect-data';
};
type ReportIncorrectDataErrors = {
    /**
     * Invalid or missing API key
     */
    401: _Error;
    /**
     * Resource not found
     */
    404: _Error;
};
type ReportIncorrectDataError = ReportIncorrectDataErrors[keyof ReportIncorrectDataErrors];
type ReportIncorrectDataResponses = {
    /**
     * Report received successfully
     */
    200: {
        success?: boolean;
        statusMessage?: string;
    };
};
type ReportIncorrectDataResponse = ReportIncorrectDataResponses[keyof ReportIncorrectDataResponses];
type GetPersonData = {
    body?: never;
    path: {
        /**
         * Watchmode person ID (starts with 7, e.g., `7110004`)
         */
        person_id: number;
    };
    query?: never;
    url: '/person/{person_id}';
};
type GetPersonErrors = {
    /**
     * Invalid or missing API key
     */
    401: _Error;
    /**
     * Resource not found
     */
    404: _Error;
};
type GetPersonError = GetPersonErrors[keyof GetPersonErrors];
type GetPersonResponses = {
    /**
     * Person details
     */
    200: Person;
};
type GetPersonResponse = GetPersonResponses[keyof GetPersonResponses];
type GetReleasesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Get releases after this date (PST timezone).
         * Format: `YYYYMMDD` or `YYYYMMDDHHMMSS`
         * Default: 30 days ago
         *
         */
        start_date?: number;
        /**
         * Get releases before this date (PST timezone).
         * Format: `YYYYMMDD` or `YYYYMMDDHHMMSS`
         * Default: 30 days from now
         *
         */
        end_date?: number;
        /**
         * Number of results (1-500)
         */
        limit?: number;
    };
    url: '/releases';
};
type GetReleasesErrors = {
    /**
     * Invalid request parameters
     */
    400: _Error;
    /**
     * Invalid or missing API key
     */
    401: _Error;
};
type GetReleasesError = GetReleasesErrors[keyof GetReleasesErrors];
type GetReleasesResponses = {
    /**
     * List of releases
     */
    200: ReleasesResponse;
};
type GetReleasesResponse = GetReleasesResponses[keyof GetReleasesResponses];
type GetTitleReleaseDatesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filter releases after this date (format YYYYMMDD)
         */
        start_date?: number;
        /**
         * Filter releases before this date (format YYYYMMDD)
         */
        end_date?: number;
    };
    url: '/title-release-dates';
};
type GetTitleReleaseDatesErrors = {
    /**
     * Unauthorized or free plan
     */
    401: _Error;
};
type GetTitleReleaseDatesError = GetTitleReleaseDatesErrors[keyof GetTitleReleaseDatesErrors];
type GetTitleReleaseDatesResponses = {
    /**
     * List of upcoming release dates
     */
    200: Array<TitleReleaseDate>;
};
type GetTitleReleaseDatesResponse = GetTitleReleaseDatesResponses[keyof GetTitleReleaseDatesResponses];
type GetNewTitlesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Get changes after this date (PST timezone).
         * Format: `YYYYMMDD` or `YYYYMMDDHHMMSS`
         * Default: 1 day ago
         *
         */
        start_date?: number;
        /**
         * Get changes before this date (PST timezone).
         * Format: `YYYYMMDD` or `YYYYMMDDHHMMSS`
         * Default: current date
         *
         */
        end_date?: number;
        /**
         * Filter by title type. Comma-separated.
         */
        types?: string;
        /**
         * Page number for pagination
         */
        page?: number;
        /**
         * Results per page (1-250)
         */
        limit?: number;
    };
    url: '/changes/new_titles';
};
type GetNewTitlesErrors = {
    /**
     * Endpoint requires paid plan
     */
    401: _Error;
};
type GetNewTitlesError = GetNewTitlesErrors[keyof GetNewTitlesErrors];
type GetNewTitlesResponses = {
    /**
     * List of new title IDs
     */
    200: ChangesResponse;
};
type GetNewTitlesResponse = GetNewTitlesResponses[keyof GetNewTitlesResponses];
type GetNewPeopleData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Get changes after this date (PST timezone).
         * Format: `YYYYMMDD` or `YYYYMMDDHHMMSS`
         * Default: 1 day ago
         *
         */
        start_date?: number;
        /**
         * Get changes before this date (PST timezone).
         * Format: `YYYYMMDD` or `YYYYMMDDHHMMSS`
         * Default: current date
         *
         */
        end_date?: number;
        /**
         * Page number for pagination
         */
        page?: number;
        /**
         * Results per page (1-250)
         */
        limit?: number;
    };
    url: '/changes/new_people';
};
type GetNewPeopleErrors = {
    /**
     * Endpoint requires paid plan
     */
    401: _Error;
};
type GetNewPeopleError = GetNewPeopleErrors[keyof GetNewPeopleErrors];
type GetNewPeopleResponses = {
    /**
     * List of new person IDs
     */
    200: PeopleChangesResponse;
};
type GetNewPeopleResponse = GetNewPeopleResponses[keyof GetNewPeopleResponses];
type GetTitlesSourcesChangedData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Get changes after this date (PST timezone).
         * Format: `YYYYMMDD` or `YYYYMMDDHHMMSS`
         * Default: 1 day ago
         *
         */
        start_date?: number;
        /**
         * Get changes before this date (PST timezone).
         * Format: `YYYYMMDD` or `YYYYMMDDHHMMSS`
         * Default: current date
         *
         */
        end_date?: number;
        /**
         * Filter by title type. Comma-separated.
         */
        types?: string;
        /**
         * Filter by region (2-letter country code). Default `US`.
         */
        regions?: string;
        /**
         * Page number for pagination
         */
        page?: number;
        /**
         * Results per page (1-250)
         */
        limit?: number;
    };
    url: '/changes/titles_sources_changed';
};
type GetTitlesSourcesChangedErrors = {
    /**
     * Endpoint requires paid plan
     */
    401: _Error;
};
type GetTitlesSourcesChangedError = GetTitlesSourcesChangedErrors[keyof GetTitlesSourcesChangedErrors];
type GetTitlesSourcesChangedResponses = {
    /**
     * List of title IDs with changed sources
     */
    200: ChangesResponse;
};
type GetTitlesSourcesChangedResponse = GetTitlesSourcesChangedResponses[keyof GetTitlesSourcesChangedResponses];
type GetTitlesDetailsChangedData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Get changes after this date (PST timezone).
         * Format: `YYYYMMDD` or `YYYYMMDDHHMMSS`
         * Default: 1 day ago
         *
         */
        start_date?: number;
        /**
         * Get changes before this date (PST timezone).
         * Format: `YYYYMMDD` or `YYYYMMDDHHMMSS`
         * Default: current date
         *
         */
        end_date?: number;
        /**
         * Filter by title type. Comma-separated.
         */
        types?: string;
        /**
         * Page number for pagination
         */
        page?: number;
        /**
         * Results per page (1-250)
         */
        limit?: number;
    };
    url: '/changes/titles_details_changed';
};
type GetTitlesDetailsChangedErrors = {
    /**
     * Endpoint requires paid plan
     */
    401: _Error;
};
type GetTitlesDetailsChangedError = GetTitlesDetailsChangedErrors[keyof GetTitlesDetailsChangedErrors];
type GetTitlesDetailsChangedResponses = {
    /**
     * List of title IDs with changed details
     */
    200: ChangesResponse;
};
type GetTitlesDetailsChangedResponse = GetTitlesDetailsChangedResponses[keyof GetTitlesDetailsChangedResponses];
type GetTitlesEpisodesChangedData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Get changes after this date (PST timezone).
         * Format: `YYYYMMDD` or `YYYYMMDDHHMMSS`
         * Default: 1 day ago
         *
         */
        start_date?: number;
        /**
         * Get changes before this date (PST timezone).
         * Format: `YYYYMMDD` or `YYYYMMDDHHMMSS`
         * Default: current date
         *
         */
        end_date?: number;
        /**
         * Page number for pagination
         */
        page?: number;
        /**
         * Results per page (1-250)
         */
        limit?: number;
    };
    url: '/changes/titles_episodes_changed';
};
type GetTitlesEpisodesChangedErrors = {
    /**
     * Endpoint requires paid plan
     */
    401: _Error;
};
type GetTitlesEpisodesChangedError = GetTitlesEpisodesChangedErrors[keyof GetTitlesEpisodesChangedErrors];
type GetTitlesEpisodesChangedResponses = {
    /**
     * List of title IDs with changed episodes
     */
    200: ChangesResponse;
};
type GetTitlesEpisodesChangedResponse = GetTitlesEpisodesChangedResponses[keyof GetTitlesEpisodesChangedResponses];

declare const client: Client;

/**
 * Configuration options for the Watchmode client
 */
interface WatchmodeClientConfig {
    /**
     * Your Watchmode API key
     * Get one free at https://api.watchmode.com/requestApiKey/
     */
    apiKey: string;
    /**
     * Base URL for the API (defaults to production)
     * @default 'https://api.watchmode.com/v1'
     */
    baseUrl?: string;
    /**
     * Custom fetch implementation (for Node.js or testing)
     */
    fetch?: typeof fetch;
}
/**
 * Search type options for autocomplete search
 * 1 = Titles and people, 2 = Titles only, 3 = Movies only, 4 = TV only, 5 = People only
 */
type AutocompleteSearchType = 1 | 2 | 3 | 4 | 5;
/**
 * Title type options
 */
type TitleType = 'movie' | 'tv_series' | 'tv_special' | 'tv_miniseries' | 'short_film';
/**
 * Source type options
 */
type SourceType = 'sub' | 'rent' | 'buy' | 'free' | 'tve';
/**
 * Sort options for list-titles endpoint
 */
type SortBy = 'relevance_desc' | 'relevance_asc' | 'popularity_desc' | 'popularity_asc' | 'release_date_desc' | 'release_date_asc' | 'title_desc' | 'title_asc';
/**
 * Official Watchmode API Client
 *
 * @example
 * ```typescript
 * import { WatchmodeClient } from '@watchmode/api-client';
 *
 * const client = new WatchmodeClient({ apiKey: 'your-api-key' });
 *
 * // Get title details
 * const { data: title } = await client.title.getDetails('3173903');
 * console.log(title?.title); // "Breaking Bad"
 *
 * // Search for titles
 * const { data: results } = await client.search.byName('inception');
 * console.log(results?.title_results);
 *
 * // Get streaming sources
 * const { data: sources } = await client.title.getSources('3173903', { regions: 'US' });
 * ```
 */
declare class WatchmodeClient {
    private client;
    /**
     * Title-related API methods
     */
    readonly title: TitleApi;
    /**
     * Search API methods
     */
    readonly search: SearchApi;
    /**
     * Person-related API methods
     */
    readonly person: PersonApi;
    /**
     * Source/Provider reference data
     */
    readonly sources: SourcesApi;
    /**
     * Releases and upcoming content
     */
    readonly releases: ReleasesApi;
    /**
     * Changes tracking (new titles, updated sources, etc.)
     */
    readonly changes: ChangesApi;
    /**
     * Account status and quota
     */
    readonly account: AccountApi;
    /**
     * Reference data (regions, networks, genres)
     */
    readonly reference: ReferenceApi;
    /**
     * Create a new Watchmode API client
     *
     * @param config - Configuration options including API key
     *
     * @example
     * ```typescript
     * const client = new WatchmodeClient({ apiKey: 'your-api-key' });
     * ```
     */
    constructor(config: WatchmodeClientConfig);
    /**
     * Get the underlying client for advanced usage
     */
    getClient(): Client;
}
/**
 * Title-related API methods
 */
declare class TitleApi {
    private client;
    constructor(client: Client);
    /**
     * Get detailed information about a movie or TV show
     *
     * @param titleId - Watchmode ID, IMDB ID (tt...), or TMDB format (movie-X, tv-X)
     * @param options - Optional parameters
     *
     * @example
     * ```typescript
     * // By Watchmode ID
     * const { data } = await client.title.getDetails('3173903');
     *
     * // By IMDB ID
     * const { data } = await client.title.getDetails('tt0903747');
     *
     * // With additional data
     * const { data } = await client.title.getDetails('3173903', {
     *   appendToResponse: 'sources,cast-crew'
     * });
     * ```
     */
    getDetails(titleId: string, options?: {
        appendToResponse?: string;
        language?: string;
        regions?: string;
    }): Promise<({
        data: TitleDetails;
        error: undefined;
    } | {
        data: undefined;
        error: _Error;
    }) & {
        request: Request;
        response: Response;
    }>;
    /**
     * Get streaming sources for a title
     *
     * @example
     * ```typescript
     * const { data: sources } = await client.title.getSources('3173903', { regions: 'US,CA' });
     * ```
     */
    getSources(titleId: string, options?: {
        regions?: string;
    }): Promise<({
        data: TitleSource[];
        error: undefined;
    } | {
        data: undefined;
        error: _Error;
    }) & {
        request: Request;
        response: Response;
    }>;
    /**
     * Get seasons for a TV series
     */
    getSeasons(titleId: string): Promise<({
        data: Season[];
        error: undefined;
    } | {
        data: undefined;
        error: _Error;
    }) & {
        request: Request;
        response: Response;
    }>;
    /**
     * Get episodes for a TV series
     */
    getEpisodes(titleId: string): Promise<({
        data: Episode[];
        error: undefined;
    } | {
        data: undefined;
        error: _Error;
    }) & {
        request: Request;
        response: Response;
    }>;
    /**
     * Get cast and crew for a title
     */
    getCastCrew(titleId: string, options?: {
        language?: string;
    }): Promise<({
        data: CastCrew[];
        error: undefined;
    } | {
        data: undefined;
        error: _Error;
    }) & {
        request: Request;
        response: Response;
    }>;
    /**
     * List titles with optional filtering
     *
     * @example
     * ```typescript
     * // Horror movies on Netflix in the US
     * const { data } = await client.title.list({
     *   types: 'movie',
     *   genres: '12', // Horror genre ID
     *   sourceIds: '203', // Netflix
     *   regions: 'US'
     * });
     * ```
     */
    list(options?: {
        types?: string;
        regions?: string;
        sourceTypes?: string;
        sourceIds?: string;
        genres?: string;
        networkIds?: string;
        languages?: string;
        releaseDateStart?: number;
        releaseDateEnd?: number;
        userRatingLow?: number;
        userRatingHigh?: number;
        criticScoreLow?: number;
        criticScoreHigh?: number;
        personId?: number;
        sortBy?: SortBy;
        page?: number;
        limit?: number;
    }): Promise<({
        data: ListTitlesResponse;
        error: undefined;
    } | {
        data: undefined;
        error: _Error;
    }) & {
        request: Request;
        response: Response;
    }>;
    /**
     * Report incorrect data for a title
     */
    reportIncorrectData(titleId: string, options?: {
        somethingWrongDescription?: 0 | 1;
        serviceIncorrect?: 0 | 1;
        sourceMissing?: 0 | 1;
        somethingElseWrong?: 0 | 1;
        somethingWrongDetails?: string;
    }): Promise<({
        data: {
            success?: boolean;
            statusMessage?: string;
        };
        error: undefined;
    } | {
        data: undefined;
        error: _Error;
    }) & {
        request: Request;
        response: Response;
    }>;
}
/**
 * Search API methods
 */
declare class SearchApi {
    private client;
    constructor(client: Client);
    /**
     * Search by name
     *
     * @example
     * ```typescript
     * const { data } = await client.search.byName('Breaking Bad');
     * ```
     */
    byName(searchValue: string, options?: {
        types?: string;
    }): Promise<({
        data: SearchResponse;
        error: undefined;
    } | {
        data: undefined;
        error: _Error;
    }) & {
        request: Request;
        response: Response;
    }>;
    /**
     * Search by IMDB ID
     *
     * @example
     * ```typescript
     * const { data } = await client.search.byImdbId('tt0903747');
     * ```
     */
    byImdbId(imdbId: string): Promise<({
        data: SearchResponse;
        error: undefined;
    } | {
        data: undefined;
        error: _Error;
    }) & {
        request: Request;
        response: Response;
    }>;
    /**
     * Search by TMDB movie ID
     */
    byTmdbMovieId(tmdbId: string | number): Promise<({
        data: SearchResponse;
        error: undefined;
    } | {
        data: undefined;
        error: _Error;
    }) & {
        request: Request;
        response: Response;
    }>;
    /**
     * Search by TMDB TV ID
     */
    byTmdbTvId(tmdbId: string | number): Promise<({
        data: SearchResponse;
        error: undefined;
    } | {
        data: undefined;
        error: _Error;
    }) & {
        request: Request;
        response: Response;
    }>;
    /**
     * Search by TMDB person ID
     */
    byTmdbPersonId(tmdbId: string | number): Promise<({
        data: SearchResponse;
        error: undefined;
    } | {
        data: undefined;
        error: _Error;
    }) & {
        request: Request;
        response: Response;
    }>;
    /**
     * Autocomplete search (optimized for typeahead)
     *
     * @example
     * ```typescript
     * const { data } = await client.search.autocomplete('break', { searchType: 2 }); // titles only
     * ```
     */
    autocomplete(searchValue: string, options?: {
        searchType?: AutocompleteSearchType;
    }): Promise<({
        data: AutocompleteResponse;
        error: undefined;
    } | {
        data: undefined;
        error: _Error;
    }) & {
        request: Request;
        response: Response;
    }>;
}
/**
 * Person API methods
 */
declare class PersonApi {
    private client;
    constructor(client: Client);
    /**
     * Get person details
     *
     * @param personId - Watchmode person ID (starts with 7)
     *
     * @example
     * ```typescript
     * const { data } = await client.person.getDetails(7110004);
     * ```
     */
    getDetails(personId: number): Promise<({
        data: Person;
        error: undefined;
    } | {
        data: undefined;
        error: _Error;
    }) & {
        request: Request;
        response: Response;
    }>;
}
/**
 * Sources/Providers API methods
 */
declare class SourcesApi {
    private client;
    constructor(client: Client);
    /**
     * List all streaming sources/providers
     *
     * @example
     * ```typescript
     * const { data: sources } = await client.sources.list({ regions: 'US', types: 'sub,free' });
     * ```
     */
    list(options?: {
        regions?: string;
        types?: string;
    }): Promise<({
        data: Source[];
        error: undefined;
    } | {
        data: undefined;
        error: _Error;
    }) & {
        request: Request;
        response: Response;
    }>;
}
/**
 * Releases API methods
 */
declare class ReleasesApi {
    private client;
    constructor(client: Client);
    /**
     * Get recent and upcoming streaming releases
     *
     * @example
     * ```typescript
     * const { data } = await client.releases.getRecent({ limit: 100 });
     * ```
     */
    getRecent(options?: {
        startDate?: number;
        endDate?: number;
        limit?: number;
    }): Promise<({
        data: ReleasesResponse;
        error: undefined;
    } | {
        data: undefined;
        error: _Error;
    }) & {
        request: Request;
        response: Response;
    }>;
    /**
     * Get upcoming release dates (paid plans only)
     */
    getUpcoming(options?: {
        startDate?: number;
        endDate?: number;
    }): Promise<({
        data: TitleReleaseDate[];
        error: undefined;
    } | {
        data: undefined;
        error: _Error;
    }) & {
        request: Request;
        response: Response;
    }>;
}
/**
 * Changes tracking API methods (paid plans only)
 */
declare class ChangesApi {
    private client;
    constructor(client: Client);
    /**
     * Get newly added titles
     */
    getNewTitles(options?: {
        startDate?: number;
        endDate?: number;
        types?: string;
        page?: number;
        limit?: number;
    }): Promise<({
        data: ChangesResponse;
        error: undefined;
    } | {
        data: undefined;
        error: _Error;
    }) & {
        request: Request;
        response: Response;
    }>;
    /**
     * Get newly added people
     */
    getNewPeople(options?: {
        startDate?: number;
        endDate?: number;
        page?: number;
        limit?: number;
    }): Promise<({
        data: PeopleChangesResponse;
        error: undefined;
    } | {
        data: undefined;
        error: _Error;
    }) & {
        request: Request;
        response: Response;
    }>;
    /**
     * Get titles with changed streaming sources
     */
    getTitlesWithSourceChanges(options?: {
        startDate?: number;
        endDate?: number;
        types?: string;
        regions?: string;
        page?: number;
        limit?: number;
    }): Promise<({
        data: ChangesResponse;
        error: undefined;
    } | {
        data: undefined;
        error: _Error;
    }) & {
        request: Request;
        response: Response;
    }>;
    /**
     * Get titles with changed details/metadata
     */
    getTitlesWithDetailChanges(options?: {
        startDate?: number;
        endDate?: number;
        types?: string;
        page?: number;
        limit?: number;
    }): Promise<({
        data: ChangesResponse;
        error: undefined;
    } | {
        data: undefined;
        error: _Error;
    }) & {
        request: Request;
        response: Response;
    }>;
    /**
     * Get titles with changed episodes
     */
    getTitlesWithEpisodeChanges(options?: {
        startDate?: number;
        endDate?: number;
        page?: number;
        limit?: number;
    }): Promise<({
        data: ChangesResponse;
        error: undefined;
    } | {
        data: undefined;
        error: _Error;
    }) & {
        request: Request;
        response: Response;
    }>;
}
/**
 * Account API methods
 */
declare class AccountApi {
    private client;
    constructor(client: Client);
    /**
     * Get API quota status
     *
     * @example
     * ```typescript
     * const { data } = await client.account.getStatus();
     * console.log(`Used ${data?.quotaUsed} of ${data?.quota} requests`);
     * ```
     */
    getStatus(): Promise<({
        data: StatusResponse;
        error: undefined;
    } | {
        data: undefined;
        error: _Error;
    }) & {
        request: Request;
        response: Response;
    }>;
}
/**
 * Reference data API methods
 */
declare class ReferenceApi {
    private client;
    constructor(client: Client);
    /**
     * Get all supported regions
     */
    getRegions(): Promise<({
        data: Region[];
        error: undefined;
    } | {
        data: undefined;
        error: _Error;
    }) & {
        request: Request;
        response: Response;
    }>;
    /**
     * Get all TV networks
     */
    getNetworks(): Promise<({
        data: Network[];
        error: undefined;
    } | {
        data: undefined;
        error: _Error;
    }) & {
        request: Request;
        response: Response;
    }>;
    /**
     * Get all genres
     */
    getGenres(): Promise<({
        data: Genre[];
        error: undefined;
    } | {
        data: undefined;
        error: _Error;
    }) & {
        request: Request;
        response: Response;
    }>;
}

export { type AutocompleteResponse, type AutocompleteResult, type AutocompleteSearchData, type AutocompleteSearchError, type AutocompleteSearchErrors, type AutocompleteSearchResponse, type AutocompleteSearchResponses, type AutocompleteSearchType, type CastCrew, type ChangesLimit, type ChangesResponse, type Client, type ClientOptions, type Config, type EndDate, type Episode, type EpisodeSource, type Genre, type GetGenresData, type GetGenresError, type GetGenresErrors, type GetGenresResponse, type GetGenresResponses, type GetNetworksData, type GetNetworksError, type GetNetworksErrors, type GetNetworksResponse, type GetNetworksResponses, type GetNewPeopleData, type GetNewPeopleError, type GetNewPeopleErrors, type GetNewPeopleResponse, type GetNewPeopleResponses, type GetNewTitlesData, type GetNewTitlesError, type GetNewTitlesErrors, type GetNewTitlesResponse, type GetNewTitlesResponses, type GetPersonData, type GetPersonError, type GetPersonErrors, type GetPersonResponse, type GetPersonResponses, type GetRegionsData, type GetRegionsError, type GetRegionsErrors, type GetRegionsResponse, type GetRegionsResponses, type GetReleasesData, type GetReleasesError, type GetReleasesErrors, type GetReleasesResponse, type GetReleasesResponses, type GetSourcesData, type GetSourcesError, type GetSourcesErrors, type GetSourcesResponse, type GetSourcesResponses, type GetStatusData, type GetStatusError, type GetStatusErrors, type GetStatusResponse, type GetStatusResponses, type GetTitleCastCrewData, type GetTitleCastCrewError, type GetTitleCastCrewErrors, type GetTitleCastCrewResponse, type GetTitleCastCrewResponses, type GetTitleDetailsData, type GetTitleDetailsError, type GetTitleDetailsErrors, type GetTitleDetailsResponse, type GetTitleDetailsResponses, type GetTitleEpisodesData, type GetTitleEpisodesError, type GetTitleEpisodesErrors, type GetTitleEpisodesResponse, type GetTitleEpisodesResponses, type GetTitleReleaseDatesData, type GetTitleReleaseDatesError, type GetTitleReleaseDatesErrors, type GetTitleReleaseDatesResponse, type GetTitleReleaseDatesResponses, type GetTitleSeasonsData, type GetTitleSeasonsError, type GetTitleSeasonsErrors, type GetTitleSeasonsResponse, type GetTitleSeasonsResponses, type GetTitleSourcesData, type GetTitleSourcesError, type GetTitleSourcesErrors, type GetTitleSourcesResponse, type GetTitleSourcesResponses, type GetTitlesDetailsChangedData, type GetTitlesDetailsChangedError, type GetTitlesDetailsChangedErrors, type GetTitlesDetailsChangedResponse, type GetTitlesDetailsChangedResponses, type GetTitlesEpisodesChangedData, type GetTitlesEpisodesChangedError, type GetTitlesEpisodesChangedErrors, type GetTitlesEpisodesChangedResponse, type GetTitlesEpisodesChangedResponses, type GetTitlesSourcesChangedData, type GetTitlesSourcesChangedError, type GetTitlesSourcesChangedErrors, type GetTitlesSourcesChangedResponse, type GetTitlesSourcesChangedResponses, type ListTitlesData, type ListTitlesError, type ListTitlesErrors, type ListTitlesResponse, type ListTitlesResponse2, type ListTitlesResponses, type Network, type Page, type PeopleChangesResponse, type Person, type PersonSearchResult, type Region, type Release, type ReleasesResponse, type ReportIncorrectDataData, type ReportIncorrectDataError, type ReportIncorrectDataErrors, type ReportIncorrectDataResponse, type ReportIncorrectDataResponses, type SearchData, type SearchError, type SearchErrors, type SearchResponse, type SearchResponse2, type SearchResponses, type Season, type SortBy, type Source, type SourceType, type StartDate, type StatusResponse, type TitleDetails, type TitleId, type TitleListItem, type TitleReleaseDate, type TitleSearchResult, type TitleSource, type TitleType, type TitleTypes, WatchmodeClient, type WatchmodeClientConfig, type _Error, WatchmodeClient as default, client as generatedClient };
